{
  "version": 3,
  "sources": ["../../src/commonFunc.ts", "../../src/token/Type.ts", "../../src/error/errorMessage.ts", "../../src/token/Token.ts", "../../src/error/ErrorInfo.ts", "../../src/Calculator.ts", "../../src/calculate.ts"],
  "sourcesContent": ["import type IntfResult from './IntfResult.js';\n\n/**\n * Evaluate the number is in range.\n * @param x Number which evaluated\n * @param above `x >= above`\n * @param below `x <= below`\n * @returns `above` <= `x` <= `below` or not\n */\nexport const inRangeAB = (x: number, above: number, below: number): boolean =>\n  x >= above && x <= below;\n\n/**\n * Evaluate the character is digit (0-9).\n * @param character Character which evaluated\n * @returns Character is digit or not\n */\nexport const isDigit = (character: string): boolean =>\n  character !== ' ' && inRangeAB(Number(character), 0, 9) ? true : false;\n\n/**\n * Detect vector or string is empty.\n * @param vector Vector `T[]` or `string`\n * @returns Vector is empty or not\n */\nexport const isEmpty = <T>(vector: T[] | string): boolean =>\n  vector.length === 0;\n\n/**\n * Convert `string` to `number`.\n * @param str String which want to convert number;\n * @returns Ok => Converted number or `undefined`\n */\nexport const toNumber = (str: string): IntfResult<number, undefined> => {\n  const num = Number(str);\n  return isNaN(num) ? {} : { Ok: num };\n};\n", "export enum Type {\n  Add,\n  Sub,\n  Mul,\n  Div,\n  Lp,\n  Rp,\n  Num,\n}\n\nexport const tokenMap: Record<Type, string | ((numeric?: string) => string)> = {\n  [Type.Add]: '+',\n  [Type.Sub]: '-',\n  [Type.Mul]: '*',\n  [Type.Div]: '/',\n  [Type.Lp]: '(',\n  [Type.Rp]: ')',\n  [Type.Num]: (numeric?: string) => numeric ?? '0',\n};\n\nexport const reverseTokenMap: Record<string, Type> = Object.fromEntries(\n  Object.entries(tokenMap)\n    .filter(([__dirname, value]) => typeof value === 'string')\n    .map(([key, value]) => [value, Number(key) as Type])\n);\n\nexport const orderMap: Record<Type, number> = {\n  [Type.Num]: 0,\n  [Type.Add]: 1,\n  [Type.Sub]: 1,\n  [Type.Mul]: 2,\n  [Type.Div]: 2,\n  [Type.Lp]: 3,\n  [Type.Rp]: 3,\n};\n", "import type IntfMessage from './IntfErrorMessage.js';\n\nexport enum MessageLevel {\n  Minimum = 0,\n  Simple = 1,\n  Medium = 2,\n  Full = 3,\n}\n\nexport enum Lang {\n  Eng = 0,\n  Jpn = 1,\n}\n\nexport enum ErrorNo {\n  Unknown = 0,\n  EmptyInput = 1,\n  TooLongInput = 2,\n  InvalidToken = 3,\n  InvalidTokenStart = 4,\n  InvalidTokenEnd = 5,\n  InvalidTokenBeforeNumber = 6,\n  InvalidTokenBeforeOperator = 7,\n  InvalidTokenBeforeLp = 8,\n  InvalidNumber = 9,\n  InvalidOperator = 10,\n  ParenthesisNotFound = 11,\n  ZeroDivide = 12,\n  InvalidResult = 13,\n}\n\n// prettier-ignore\nconst ERROR_MESSAGE = {\n  SIMPLE: [\n    { eng: \"Unknown error\", jpn: \"\u672A\u77E5\u306E\u30A8\u30E9\u30FC\" }, // Index 0 (errorNo: _)\n    { eng: \"Input error\", jpn: \"\u5165\u529B\u30A8\u30E9\u30FC\" }, // Index 1 (errorNo: 1-2)\n    { eng: \"Syntax error\", jpn: \"\u69CB\u6587\u30A8\u30E9\u30FC\" }, // Index 2 (errorNo: 3-11)\n    { eng: \"Calculate error\", jpn: \"\u8A08\u7B97\u30A8\u30E9\u30FC\" }, // Index 3 (errorNo: 12-13)\n  ] as IntfMessage[],\n  MEDIUM: [\n    { eng: \"Unknown error\", jpn: \"\u672A\u77E5\u306E\u30A8\u30E9\u30FC\u3067\u3059\" }, // Index 0 (errorNo: _)\n    { eng: \"Input is empty\", jpn: \"\u5F0F\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\" }, // Index 1 (errorNo: 1)\n    { eng: \"Input is too long\", jpn: \"\u5F0F\u304C\u9577\u3059\u304E\u307E\u3059\" }, // Index 2 (errorNo: 2)\n    { eng: \"Invalid token\", jpn: \"\u7121\u52B9\u306A\u6587\u5B57\u304C\u3042\u308A\u307E\u3059\" }, // Index 3 (errorNo: 3-8)\n    { eng: \"Invalid number\", jpn: \"\u7121\u52B9\u306A\u6570\u5024\u304C\u3042\u308A\u307E\u3059\" }, // Index 4 (errorNo: 9)\n    { eng: \"Invalid operator\", jpn: \"\u7121\u52B9\u306A\u6F14\u7B97\u5B50\u304C\u3042\u308A\u307E\u3059\" }, // Index 5 (errorNo: 10)\n    { eng: \"() is not found\", jpn: \"\u5BFE\u5FDC\u3059\u308B () \u304C\u3042\u308A\u307E\u305B\u3093\" }, // Index 6 (errorNo: 11)\n    { eng: \"Zero divide\", jpn: \"\u30BC\u30ED\u9664\u7B97\u306F\u3067\u304D\u307E\u305B\u3093\" }, // Index 7 (errorNo: 12)\n    { eng: \"Invalid Result\", jpn: \"\u8A08\u7B97\u7D50\u679C\u304C\u7121\u52B9\u3067\u3059\" }, // Index 8 (errorNo: 13)\n  ] as IntfMessage[],\n  FULL: [\n    { eng: \"Unknown error\", jpn: \"\u672A\u77E5\u306E\u30A8\u30E9\u30FC\u3067\u3059\" }, // Index 0 (errorNo: _)\n    { eng: \"Input is empty\", jpn: \"\u5F0F\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\" }, // Index 1 (errorNo: 1)\n    { eng: \"Input is too long\", jpn: \"\u5F0F\u304C\u9577\u3059\u304E\u307E\u3059\" }, // Index 2 (errorNo: 2)\n    { eng: \"Invalid token\", jpn: \"\u7121\u52B9\u306A\u6587\u5B57\u304C\u5165\u3063\u3066\u3044\u307E\u3059\" }, // Index 3 (errorNo: 3)\n    { eng: \"Invalid token at start\", jpn: \"\u5148\u982D\u306B\u7121\u52B9\u306A\u6587\u5B57\u304C\u5165\u3063\u3066\u3044\u307E\u3059\"}, // Index 4 (errorNo: 4)\n    { eng: \"Invalid token at end\", jpn: \"\u672B\u5C3E\u306B\u7121\u52B9\u306A\u6587\u5B57\u304C\u5165\u3063\u3066\u3044\u307E\u3059\" }, // Index 5 (errorNo: 5)\n    { eng: \"Invalid token before number\", jpn: \"\u6570\u5024\u306E\u524D\u306B\u7121\u52B9\u306A\u6587\u5B57\u304C\u5165\u3063\u3066\u3044\u307E\u3059\" }, // Index 6 (errorNo: 6)\n    { eng: \"Invalid token before operator\", jpn: \"\u6F14\u7B97\u5B50\u306E\u524D\u306B\u7121\u52B9\u306A\u6587\u5B57\u304C\u5165\u3063\u3066\u3044\u307E\u3059\" }, // Index 7 (errorNo: 7)\n    { eng: \"Invalid token before (\", jpn: \"( \u306E\u524D\u306B\u7121\u52B9\u306A\u6587\u5B57\u304C\u5165\u3063\u3066\u3044\u307E\u3059\" }, // Index 8 (errorNo: 8)\n    { eng: \"Invalid number\", jpn: \"\u3053\u306E\u6570\u5024\u306F\u7121\u52B9\u3067\u3059\" }, // Index 9 (errorNo: 9)\n    { eng: \"Invalid operator\", jpn: \"\u3053\u306E\u6F14\u7B97\u5B50\u306F\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093\" }, // Index 10 (errorNo: 10)\n    { eng: \"() is not found\", jpn: \"\u5BFE\u5FDC\u3059\u308B () \u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\" }, // Index 11 (errorNo: 11)\n    { eng: \"Zero divide\", jpn: \"\u30BC\u30ED\u9664\u7B97\u306F\u3067\u304D\u307E\u305B\u3093\" }, // Index 12 (errorNo: 12)\n    { eng: \"Result is not a number\", jpn: \"\u8A08\u7B97\u7D50\u679C\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093\" }, // Index 13 (errorNo: 13)\n  ] as IntfMessage[],\n  MINIMUM: [{ eng: \"Error\", jpn: \"\u30A8\u30E9\u30FC\" }] as IntfMessage[],\n} as const;\n\nexport function getMessage(\n  messageIndex: number,\n  errorLang: Lang,\n  messageLevel: MessageLevel\n): string {\n  const getMessage = (level: MessageLevel): IntfMessage[] => {\n    switch (level) {\n      case MessageLevel.Simple:\n        return ERROR_MESSAGE.SIMPLE;\n      case MessageLevel.Medium:\n        return ERROR_MESSAGE.MEDIUM;\n      case MessageLevel.Full:\n        return ERROR_MESSAGE.FULL;\n      case MessageLevel.Minimum:\n        return ERROR_MESSAGE.MINIMUM;\n      default:\n        return ERROR_MESSAGE.MINIMUM;\n    }\n  };\n\n  const extractMessage = (lang: Lang, message: IntfMessage): string => {\n    switch (lang) {\n      case Lang.Eng:\n        return message.eng;\n      case Lang.Jpn:\n        return message.jpn;\n      default:\n        return ERROR_MESSAGE.MINIMUM[0].eng;\n    }\n  };\n\n  const messages = getMessage(messageLevel);\n  const index = messageIndex < messages.length ? messageIndex : 0;\n\n  return extractMessage(errorLang, messages[index]);\n}\n", "import { orderMap, tokenMap, Type } from './Type.js';\n\nexport default class Token {\n  public readonly str: string;\n  public readonly order: number;\n\n  constructor(\n    public readonly type: Type,\n    numeric?: string\n  ) {\n    const token = tokenMap[type];\n    this.str = typeof token === 'function' ? token(numeric) : token;\n    this.order = orderMap[type];\n  }\n\n  public match(type: Type): boolean {\n    return this.type === type;\n  }\n\n  public matchAll(types: Type[]): boolean {\n    return new Set(types).has(this.type);\n  }\n\n  public isSign() {\n    return this.matchAll([Type.Add, Type.Sub]);\n  }\n\n  public isBeforeSign() {\n    return this.matchAll([Type.Add, Type.Sub, Type.Mul, Type.Div, Type.Lp]);\n  }\n\n  public isArithmetic() {\n    return this.matchAll([Type.Add, Type.Sub, Type.Mul, Type.Div]);\n  }\n\n  public isParenthesis() {\n    return this.matchAll([Type.Lp, Type.Rp]);\n  }\n}\n", "import { inRangeAB } from '../commonFunc.js';\nimport { ErrorNo, getMessage, Lang, MessageLevel } from './errorMessage.js';\n\nexport default class ErrorInfo {\n  public hasError: boolean;\n  public errorNumber: ErrorNo;\n  public errorFunction: string;\n  private readonly messageLevel: MessageLevel;\n  private readonly messageLang: Lang;\n\n  constructor(messageLevel: number, language: Lang) {\n    const getLevel = (): MessageLevel => {\n      switch (messageLevel) {\n        case MessageLevel.Simple:\n        case MessageLevel.Medium:\n        case MessageLevel.Full:\n          return messageLevel;\n        default:\n          return MessageLevel.Minimum;\n      }\n    };\n\n    const getLanguage = (): Lang => {\n      switch (language) {\n        case Lang.Eng:\n        case Lang.Jpn:\n          return language;\n        default:\n          return Lang.Eng;\n      }\n    };\n\n    this.hasError = false;\n    this.errorNumber = 0;\n    this.errorFunction = '';\n    this.messageLevel = getLevel();\n    this.messageLang = getLanguage();\n  }\n\n  private getMessageText(messageIndex: number): string {\n    return getMessage(messageIndex, this.messageLang, this.messageLevel);\n  }\n\n  private generateMessage(\n    messageIndex: number,\n    includeErrorNumber: boolean,\n    includeFunction: boolean\n  ): string {\n    const messageText = this.getMessageText(messageIndex);\n\n    const getBaseMessage = (): string => {\n      switch (this.messageLang) {\n        case Lang.Eng:\n          return this.messageLevel === MessageLevel.Minimum\n            ? 'Error'\n            : 'Error ';\n        case Lang.Jpn:\n          return '\u30A8\u30E9\u30FC';\n      }\n    };\n\n    const errorPart: string = includeErrorNumber\n      ? `${this.errorNumber}: ${messageText}`\n      : `: ${messageText}`;\n\n    const functionPart: string = includeFunction\n      ? ` [function ${this.errorFunction}()]`\n      : '';\n\n    return `${getBaseMessage()}${errorPart}${functionPart}`;\n  }\n\n  private getSimpleMessage(): string {\n    const getMessageIndex = (): number => {\n      const errorNumber = this.errorNumber;\n\n      if (inRangeAB(errorNumber, ErrorNo.EmptyInput, ErrorNo.TooLongInput)) {\n        return 1;\n      } else if (\n        inRangeAB(\n          errorNumber,\n          ErrorNo.InvalidToken,\n          ErrorNo.ParenthesisNotFound\n        )\n      ) {\n        return 2;\n      } else if (\n        inRangeAB(errorNumber, ErrorNo.ZeroDivide, ErrorNo.InvalidResult)\n      ) {\n        return 3;\n      } else {\n        return 0;\n      }\n    };\n\n    return this.generateMessage(getMessageIndex(), false, false);\n  }\n\n  private getMediumMessage(): string {\n    const getMessageIndex = (): number => {\n      const errorNumber = this.errorNumber;\n\n      if (\n        inRangeAB(\n          errorNumber,\n          ErrorNo.InvalidToken,\n          ErrorNo.InvalidTokenBeforeLp\n        )\n      ) {\n        return 3;\n      } else if (\n        inRangeAB(errorNumber, ErrorNo.EmptyInput, ErrorNo.ZeroDivide)\n      ) {\n        return errorNumber;\n      } else {\n        return 0;\n      }\n    };\n\n    return this.generateMessage(getMessageIndex(), true, false);\n  }\n\n  private getFullMessage(): string {\n    return this.generateMessage(this.errorNumber, true, true);\n  }\n\n  private getMinimumMessage(): string {\n    return this.getMessageText(0);\n  }\n\n  public outputError(): string {\n    switch (this.messageLevel) {\n      case MessageLevel.Simple:\n        return this.getSimpleMessage();\n      case MessageLevel.Medium:\n        return this.getMediumMessage();\n      case MessageLevel.Full:\n        return this.getFullMessage();\n      case MessageLevel.Minimum:\n        return this.getMinimumMessage();\n      default:\n        return this.getMinimumMessage();\n    }\n  }\n\n  public setError(error: ErrorNo, func: string) {\n    this.errorNumber = error;\n    this.errorFunction = func;\n    this.hasError = true;\n  }\n}\n", "import { isDigit, isEmpty, toNumber } from './commonFunc.js';\nimport { reverseTokenMap, Type } from './token/Type.js';\nimport { ErrorNo } from './error/errorMessage.js';\nimport Token from './token/Token.js';\nimport ErrorInfo from './error/ErrorInfo.js';\nimport type IntfResult from './IntfResult.js';\n\nexport default class Calculator {\n  private formula: Token[];\n  private formulaRPN: Token[];\n  private result: string;\n  private readonly error: ErrorInfo;\n  private readonly maxFormulaLength: number;\n\n  constructor(level: number, language: number, maxFormulaLength: number) {\n    this.formula = [];\n    this.formulaRPN = [];\n    this.result = '';\n    this.error = new ErrorInfo(level, language);\n    this.maxFormulaLength = maxFormulaLength;\n  }\n\n  public run(input: string): string {\n    this.scanInput(input)\n      .checkSyntax()\n      .convertRPN()\n      .calculateRPN()\n      .removeTrailingZero();\n\n    return this.error.hasError ? this.error.outputError() : this.result;\n  }\n\n  private catchError(error: ErrorNo, func: string): Calculator {\n    this.error.setError(error, func);\n    return this;\n  }\n\n  private scanInput(input: string): Calculator {\n    const FUNC_NAME = 'scanInput';\n    const numericBuffer: string[] = [];\n    let lastToken: Token | null = null;\n\n    // Error: Formula is empty\n    if (input.length < 1) {\n      return this.catchError(ErrorNo.EmptyInput, FUNC_NAME);\n    }\n\n    // Error: Formula is too long\n    if (input.length > this.maxFormulaLength) {\n      return this.catchError(ErrorNo.TooLongInput, FUNC_NAME);\n    }\n\n    // Scan input formula\n    for (const character of input) {\n      // Token is digit or decimal point\n      if (isDigit(character) || character === '.') {\n        numericBuffer.push(character);\n        continue;\n      }\n\n      if (!isEmpty(numericBuffer)) {\n        // Register numericBuffer to formula\n        this.formula.push(new Token(Type.Num, numericBuffer.join('')));\n        lastToken = this.formula.at(-1)!; // Update lastToken\n      }\n\n      // Token is operator or sign\n      if (character === '+' || character === '-') {\n        // Token is sign\n        if (lastToken === null || lastToken.isBeforeSign()) {\n          numericBuffer.push(character);\n          continue;\n        }\n      }\n\n      numericBuffer.length = 0; // Clear numericBuffer\n\n      if (!(character === '\\n' || character === ' ')) {\n        const type = reverseTokenMap[character];\n\n        if (type !== undefined) {\n          this.formula.push(new Token(type));\n        } else {\n          return this.catchError(ErrorNo.InvalidToken, FUNC_NAME);\n        }\n      }\n      lastToken = this.formula.at(-1)!; // update lastToken\n    }\n\n    // Formula has only number\n    if (numericBuffer.length !== 0) {\n      this.formula.push(new Token(Type.Num, numericBuffer.join('')));\n    }\n    return this;\n  }\n\n  private checkSyntax(): Calculator {\n    const FUNC_NAME = 'checkSyntax';\n    const formula = this.formula;\n    let depth = 0;\n\n    if (this.error.hasError) return this; // Skip this function;\n\n    if (formula.length === 1) {\n      const firstToken = formula[0];\n      if (firstToken.match(Type.Num)) {\n        if (!isNaN(Number(firstToken.str))) {\n          this.result = firstToken.str;\n          return this;\n        } else {\n          return this.catchError(ErrorNo.InvalidNumber, FUNC_NAME);\n        }\n      } else {\n        return this.catchError(ErrorNo.InvalidToken, FUNC_NAME);\n      }\n    }\n\n    for (const [index, token] of formula.entries()) {\n      if (index === 0) {\n        switch (token.type) {\n          case Type.Mul:\n          case Type.Div:\n          case Type.Rp:\n            return this.catchError(ErrorNo.InvalidTokenStart, FUNC_NAME);\n          case Type.Lp:\n            ++depth;\n            break;\n        }\n        continue;\n      }\n\n      if (\n        index === formula.length - 1 &&\n        (token.isArithmetic() || token.match(Type.Lp))\n      ) {\n        return this.catchError(ErrorNo.InvalidTokenEnd, FUNC_NAME);\n      }\n\n      const prevToken = formula[index - 1];\n\n      switch (token.type) {\n        case Type.Num:\n          switch (prevToken.type) {\n            case Type.Rp:\n              return this.catchError(\n                ErrorNo.InvalidTokenBeforeNumber,\n                FUNC_NAME\n              );\n            case Type.Num:\n              return this.catchError(ErrorNo.InvalidOperator, FUNC_NAME);\n          }\n          break;\n        case Type.Add:\n        case Type.Sub:\n        case Type.Mul:\n        case Type.Div:\n          if (prevToken.isArithmetic()) {\n            return this.catchError(\n              ErrorNo.InvalidTokenBeforeOperator,\n              FUNC_NAME\n            );\n          }\n          break;\n        case Type.Lp:\n          ++depth;\n          if (prevToken.matchAll([Type.Num, Type.Rp])) {\n            return this.catchError(ErrorNo.InvalidTokenBeforeLp, FUNC_NAME);\n          }\n          break;\n        case Type.Rp:\n          --depth;\n          if (prevToken.match(Type.Lp)) {\n            return this.catchError(ErrorNo.InvalidToken, FUNC_NAME);\n          }\n          break;\n      }\n    }\n\n    if (!this.error.hasError && depth !== 0) {\n      return this.catchError(ErrorNo.ParenthesisNotFound, FUNC_NAME);\n    }\n    return this;\n  }\n\n  private convertRPN(): Calculator {\n    const FUNC_NAME = 'convertRPN';\n    const optStack: Token[] = [];\n\n    if (this.error.hasError) return this; // Skip this function;\n\n    if (isEmpty(this.result)) {\n      for (const token of this.formula) {\n        switch (token.type) {\n          case Type.Num:\n            this.formulaRPN.push(token);\n            break;\n          case Type.Lp:\n            optStack.push(token);\n            break;\n          case Type.Rp:\n            let isRp = false;\n\n            while (!isRp) {\n              if (isEmpty(optStack)) {\n                return this.catchError(ErrorNo.ParenthesisNotFound, FUNC_NAME);\n              }\n\n              if (optStack.at(-1)!.match(Type.Lp)) {\n                optStack.pop();\n                isRp = true;\n              } else {\n                this.formulaRPN.push(optStack.pop()!);\n              }\n            }\n            break;\n          case Type.Add:\n          case Type.Sub:\n          case Type.Mul:\n          case Type.Div:\n            while (\n              !isEmpty(optStack) &&\n              optStack.at(-1)!.isArithmetic() &&\n              token.order <= optStack.at(-1)!.order\n            ) {\n              this.formulaRPN.push(optStack.pop()!);\n            }\n            optStack.push(token);\n            break;\n        }\n      }\n\n      while (!isEmpty(optStack)) {\n        const token = optStack.pop();\n\n        if (token!.isParenthesis()) {\n          return this.catchError(ErrorNo.ParenthesisNotFound, FUNC_NAME);\n        }\n\n        this.formulaRPN.push(token!);\n      }\n    }\n    return this;\n  }\n\n  private calculateRPN(): Calculator {\n    const FUNC_NAME = 'calculateRPN';\n    const operandStack: number[] = [];\n\n    const binaryOperation = (\n      y: number,\n      x: number,\n      operator: Token\n    ): IntfResult<number, ErrorNo> => {\n      switch (operator.type) {\n        case Type.Add:\n          return { Ok: x + y };\n        case Type.Sub:\n          return { Ok: x - y };\n        case Type.Mul:\n          return { Ok: x * y };\n        case Type.Div:\n          return y === 0 ? { Err: ErrorNo.ZeroDivide } : { Ok: x / y };\n        default:\n          return { Err: ErrorNo.InvalidOperator };\n      }\n    };\n\n    /**\n     * Calculate length of after decimal separator.\n     * @param numeric Number to be measured\n     * @returns Length of after decimal separator\n     */\n    const afterDSLength = (numeric: number): number => {\n      const DS_LENGTH = 1; // Length of decimal separator (DS)\n      const str = Math.abs(numeric).toString(); // Remove minus sign\n      const integerLength = str.indexOf('.') + DS_LENGTH; // Length of integer and DS\n      return str.includes('.') ? str.length - integerLength : 0; // Length of after DS\n    };\n\n    const checkScale = (numeric: number, scale: number): string =>\n      afterDSLength(numeric) > scale\n        ? numeric.toFixed(scale)\n        : numeric.toString();\n\n    if (this.error.hasError) return this; // Skip this function;\n\n    if (isEmpty(this.result)) {\n      for (const token of this.formulaRPN) {\n        if (token.isArithmetic()) {\n          const result = binaryOperation(\n            operandStack.pop()!,\n            operandStack.pop()!,\n            token\n          );\n          if (result.Ok !== undefined) {\n            operandStack.push(result.Ok);\n            if (isNaN(result.Ok)) {\n              return this.catchError(ErrorNo.InvalidResult, FUNC_NAME);\n            }\n          } else if (result.Err !== undefined) {\n            return this.catchError(result.Err, FUNC_NAME);\n          }\n        } else if (token.match(Type.Num)) {\n          const result = toNumber(token.str);\n          if (result.Ok !== undefined) {\n            operandStack.push(result.Ok);\n          } else {\n            return this.catchError(ErrorNo.InvalidNumber, FUNC_NAME);\n          }\n        }\n      }\n      this.result = checkScale(operandStack.pop()!, 10);\n    }\n    return this;\n  }\n\n  private removeTrailingZero(): Calculator {\n    const rawResult = this.result;\n\n    if (this.error.hasError) return this; // Skip this function;\n\n    if (rawResult.includes('.')) {\n      const resultVec: string[] = rawResult.split('');\n\n      // Remove trailing 0\n      while (resultVec.at(-1) === '0') resultVec.pop();\n\n      // Remove trailing .\n      if (resultVec.at(-1) === '.') resultVec.pop();\n\n      this.result = resultVec.join('');\n    }\n    return this;\n  }\n}\n", "import Calculator from './Calculator.js';\n\nexport const calculate = (\n  formula: string,\n  errorLevel: number,\n  errorLang: number,\n  maxFromulaLength: number\n): string =>\n  new Calculator(errorLevel, errorLang, maxFromulaLength).run(formula);\n"],
  "mappings": "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",
  "names": ["inRangeAB", "x", "above", "below", "isDigit", "character", "isEmpty", "vector", "toNumber", "str", "num", "tokenMap", "numeric", "reverseTokenMap", "__dirname", "value", "key", "orderMap", "ERROR_MESSAGE", "getMessage", "messageIndex", "errorLang", "messageLevel", "level", "extractMessage", "lang", "message", "messages", "index", "Token", "type", "numeric", "token", "tokenMap", "orderMap", "types", "ErrorInfo", "messageLevel", "language", "getLevel", "getLanguage", "messageIndex", "getMessage", "includeErrorNumber", "includeFunction", "messageText", "getBaseMessage", "errorPart", "functionPart", "getMessageIndex", "errorNumber", "inRangeAB", "error", "func", "Calculator", "level", "language", "maxFormulaLength", "ErrorInfo", "input", "error", "func", "FUNC_NAME", "numericBuffer", "lastToken", "character", "isDigit", "isEmpty", "Token", "type", "reverseTokenMap", "formula", "depth", "firstToken", "index", "token", "prevToken", "optStack", "isRp", "operandStack", "binaryOperation", "y", "x", "operator", "afterDSLength", "numeric", "str", "integerLength", "checkScale", "scale", "result", "toNumber", "rawResult", "resultVec", "calculate", "formula", "errorLevel", "errorLang", "maxFromulaLength", "Calculator"]
}
